---
title: "Living Planet Symposiom 2022: openEO platform R-Client Classroom"
author: 
 - Peter Zellner, Eurac Research
 - Florian Lahn, EFTAS
 - Matthias Mohr, University of Münster
 - Mattia Rossi, Eurac Research
date: "11/05/2022"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: TRUE
---

![](https://webassets.eurac.edu/31538/1629894586-open-eo-platform.png?fit=max&fm=jpg&w=1000){width="400"}

![](https://www.eurac.edu/_next/image?url=https%253A%252F%252Fwebassets.eurac.edu%252F31538%252F1634027841-logoproject.png%253Fauto%253Dformat%2526fit%253Dclip%2526fm%253Djpg%2526h%253D300%2526w%253D300&w=640&q=85){width="116"}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preface

## Before you start...

-   the openEO platform getting started guide <https://docs.openeo.cloud/getting-started/r/>
-   the openEO R-Client vignettes <https://open-eo.github.io/openeo-r-client/>
-   and the R-Client repo for logging issues and collaborating <https://github.com/Open-EO/openeo-r-client>
-   Introduction to data-cubes <https://openeo.org/documentation/1.0/datacubes.html>

## Topics

-   Installation of the openEO R-Client
-   Authentication and Log-In
-   Discovery of collections and processes
-   Usability and R-Studio integration
-   Processing
-   Analyze results

# Installation of the openEO R-Client

The openEO R-Client is available on CRAN. Install via `install.packages("openeo")`.

In case you want to use a specific version of the R-Client you can install it from the [openEO github repository](https://github.com/Open-EO/openeo-r-client).

It can be installed via `remotes::install_github()`. For the dev version set `remotes::install_gitub(remotes::install_github(repo="Open-EO/openeo-r-client",ref="develop", dependencies=TRUE)`.

```{r install, eval=FALSE}
install.packages("openeo")
packageVersion("openeo") >= '1.2.0'
```

## Useful libraries

Load the openEO R-Client library and some other useful libraries.

```{r libs, message=FALSE, warning=FALSE}
library(openeo)
library(stars)
library(sf)
library(mapview)
library(mapedit)
library(dplyr)
library(ggplot2)
library(plotly)
```

# Authentication and Login

## Authentication

Before you can use openEO Platform you need a user account to authenticate yourself. To handle authentication, openEO leverages [OpenID Connect (OIDC)](https://openid.net/connect/). The [general authentication documentation for openEO Platform](https://docs.openeo.cloud/authentication/#authentication) describes the authentication procedure in more detail.

## Login

First connect to the backend. This allows to discover the collections (as seen in the connections pane) and the processes.

In a second step log in. This allows to use the full functionality of openEO Platform including processing. Slight differences will occur depending on the type of account you have (e.g., free tier, early adopter).

```{r connect_and_login}
host = "https://openeo.cloud"
con = openeo::connect(host)
login()
```

Sometimes it's useful to get your account information and check whether you are still logged in.

```{r check_login}
describe_account()
con$isConnected()
con$isLoggedIn()
```

# Discovery of collections and processes

Once you're connected you can discover processes and collections. This gives you valuable metadata on collections and information on how to use the processes.

## Discover collections

The collections appear in the connections pane of R-Studio. You can also list them via `list_collections()` and retrieve some first info.

```{r list_collections}
names(list_collections()) %>% as.data.frame()
```

For more interactivity you can use the `collection_viewer()` which opens the collection list the viewer pane.

```{r collection_viewer, eval=FALSE}
collection_viewer()
```

For visualizing collection metadata within a report, use `describe_collection()`.

```{r describe_collection}
coll_meta = openeo::describe_collection("SENTINEL2_L1C_SENTINELHUB")
coll_meta
```

To use the collection metadata for further coding you can use the content of `describe_collection()`.

```{r describe_collection}
ext = coll_meta$extent$spatial # you could use this to draw a bbox of the collection
st_bbox(obj = c(xmin = ext[1], ymin = ext[2], xmax = ext[3], ymax = ext[4]), crs = 4326) %>% mapview()

```

## Discover processes

To get an overview of the available processes use `list_processes()`

```{r list_processes}
names(list_processes()) %>% as.data.frame()
```

For more interactivity and ad-hoc help you can use the `process_viewer()` which opens the process list the viewer pane.

```{r process_viewer, eval=FALSE}
process_viewer()
```

`describe_process()` will render a specific process in a report.

```{r describe_process}
describe_process("reduce_dimension")
```

# Processing

-   Load Sentinel 2 L1C data
-   Define the area of interest, temporal range and bands
-   Atmospherically correct the values on the fly
-   Aggregate monthly means
-   Calculate the NDVI
-   Download the result

## Definitions

First define an area of interest interactively (either a point or area). You can also use multiple features and loop through them later on.

```{r aoi_process}
# this is interactive
pnts = mapedit::drawFeatures()

# this is static for areas - Frascati
# pnts = c(xmin = 12.64805, ymin = 41.80398, xmax = 12.6517, ymax = 41.80603)
# pnts = st_bbox(pnts, crs = st_crs(4326))
mapview(pnts)

bbox = st_bbox(pnts)
bbox = list(west = bbox[[1]],
            east = bbox[[3]],
            south = bbox[[2]],
            north = bbox[[4]])
```

Define the collection (data set), time range and bands.

```{r defs_process}
collection = "SENTINEL2_L1C_SENTINELHUB"
time_range = list("2018-01-01T00:00:00.000Z", 
                  "2018-12-31T00:00:00.000Z")
bands = c("B04", "B08", "CLP", "B09", "B8A", "B11",
          "sunAzimuthAngles", "sunZenithAngles", "viewAzimuthMean", "viewZenithMean")
#bands = c("B04", "B08")
```

## Build the processing chain

Start building the processing chain. First, load the available processes. You can access the available processes assigned to `p` here via the `$` operator.

⚠️ Auto-completion is a very helpful feature ⚠️

```{r load_processes, eval=FALSE}
p = processes()
# names(p)
```

Load the collection.

```{r load_data, eval=FALSE}
data = p$load_collection(id = collection, 
                         spatial_extent = bbox,
                         temporal_extent = time_range, 
                         bands = bands) %>% 
  p$atmospheric_correction(method = "smac")
  
```

Atmospherical Correction. The different processes can be chained using the pipe `%>%`.

```{r atmopspherical_correction, eval=FALSE}
boa_corr = p$atmospheric_correction(data = data, method = "smac") # or use "iCor"
```

Calculate NDVI. Reduce the "bands" dimension with the well known NDVI formula.

```{r calc_ndvi, eval=FALSE}
ndvi_calc = p$reduce_dimension(data = boa_corr, 
                               dimension = "bands", 
                               reducer = function(data, context) {
                                 red = data[1]
                                 nir = data[2]
                                 (nir-red)/(nir+red)})

```

Aggregate to temporal periods.

```{r temporal_period, eval=FALSE}
# process_viewer("aggregate_temporal")

intervals = list(c('2018-01-02', '2018-02-01'),
                 c('2018-02-01', '2018-03-01'),
                 c('2018-03-01', '2018-04-01'),
                 c('2018-04-01', '2018-05-01'),
                 c('2018-05-01', '2018-06-01'), 
                 c('2018-06-01', '2018-07-01'), 
                 c('2018-07-01', '2018-08-01'),
                 c('2018-08-01', '2018-09-01'),
                 c('2018-09-01', '2018-10-01'), 
                 c('2018-10-01', '2018-11-01'),
                 c('2018-11-01', '2018-12-30'))

labels = lapply(intervals, function(x){x[[1]]}) %>% unlist() # create labels from list

ndvi_mnth = p$aggregate_temporal(data = ndvi_calc,
                                 intervals = intervals,
                                 reducer = function(data, context){p$median(data)},
                                 labels = labels,
                                 dimension = "t")
```

Save the result.

```{r save_result, eval=FALSE}
result = p$save_result(data = ndvi_mnth, format="NetCDF")
```

No processing has happened so far. Only the workflow/process graph has been defined.

```{r vis_graph, eval=FALSE}
graph_info = create_user_process(result, id = "test", submit = FALSE)
parse_graph(graph_info)
```

## Compute the result

synchronous call (result is computed directly)

```{r out_name}
out_name =  "/home/pzellner@eurac.edu/git_projects/sample-notebooks/r_ndvi_mnth_int.nc"
```

```{r compute_result, eval=FALSE}
a = Sys.time()
compute_result(result,
               format = "netCDF",
               output_file = out_name, 
               con = con)
b = Sys.time()-a
b
```

# Analyze Results

## Load Results

```{r load_result}
# load the data into r
ndvi = read_ncdf(out_name)

# check which projection your data has and assign it
#system(paste0("gdalinfo ", out_name))
st_crs(ndvi) = st_crs(32633)

# look at the time dimension
stars::st_get_dimension_values(ndvi, "t")
```

plot some time slices (select and deselect in the viewer)

```{r plot_area}
brks = seq(-0, 1, 0.1)
mapview(ndvi %>% slice("t", 3), at = brks) + 
  mapview(ndvi %>% slice("t", 5), at = brks) + 
  mapview(ndvi %>% slice("t", 7), at = brks) +
  mapview(ndvi %>% slice("t", 9), at = brks)
```

get a point for plotting a pixel timeseries

```{r get_pixel}
# define a point
pixel = mapedit::drawFeatures()

# static assignment
# pixel = data.frame(x = 12.64956, y = 41.80526)
# pixel = st_as_sf(pixel, coords = c("x", "y"), crs = st_crs(4326))

mapview(pixel) + mapview(st_bbox(ndvi))
```

subset to a point and plot a pixel time series

```{r plot_}
# subset to point
pixel = st_transform(x = pixel, crs = st_crs(ndvi))
ndvi_ts = ndvi[pixel]

# generate a data frame from the values and dates
ndvi_ts_df = data.frame(value = ndvi_ts %>% pull() %>% c() %>% as.vector(), 
                        dates = as.Date(st_get_dimension_values(ndvi_ts, "t")))

# plot the timeseries
plot_ts = ggplot(ndvi_ts_df, aes(x = dates, y = value)) + 
  geom_line() + 
  geom_point()
plot_ts_plotly = plotly::ggplotly(plot_ts)
plot_ts_plotly

```

Retrieving the point timeseries could also be done via openEO platform directly. Just replace the spatial extent with a point (duplicate x and y values) and save the reslut as netcdf.

# Todo:

## Viewing COGs (mapview -\> try)

## Compare to Webeditor

## Code Converter

## Demo

# 
